//
//  File.swift
//  
//
//  Created by Dmitry Bespalov on 03.01.22.
//

import Foundation
import Solidity
import XCTest

class FixedArrayEncodingTests: XCTestCase {
    func testEncodeStaticFixedArray() {
        // encoded as a tuple of k elements
        // bytes3[2] = (bytes3, bytes3)
        let value = Sol.FixedArray(size: 2, elements: [
            Sol.Bytes3(storage: Data([0xaa, 0xbb, 0xcc])),
            Sol.Bytes3(storage: Data([0x11, 0x22, 0x33]))
        ])
        let expected = Data([
            // 0 element
            0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes
            // 1 element
            0x11, 0x22, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes
        ])
        let data = value.encode()
        XCTAssertEqual(Array(data), Array(expected))
    }

    func testDecodeStaticFixedArray() throws {
        let data = Data([
            // 0 element
            0xaa, 0xbb, 0xcc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes
            // 1 element
            0x11, 0x22, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes
        ])
        var value = Sol.FixedArray(size: 2, repeating: Sol.Bytes3())
        var offset = 0
        try value.decode(from: data, offset: &offset)
        continueAfterFailure = false
        XCTAssertEqual(value.elements.count, 2)
        XCTAssertEqual(Array(value.elements[0].storage), [0xaa, 0xbb, 0xcc])
        XCTAssertEqual(Array(value.elements[1].storage), [0x11, 0x22, 0x33])
        XCTAssertEqual(offset, 64)
    }

    func testEncodeDynamicFixedArray() {
        // bytes[2] = encoded as (bytes, bytes)
        // (bytes, bytes) encoded as
        let value = Sol.FixedArray(size: 2, elements: [Sol.Bytes(storage: Data([0xaa])), Sol.Bytes(storage: Data([0xbb]))])
        let expected = Data([
            // head[0] = location of the 1st 'bytes' = heads size = 64 = 0x40
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, // 32 bytes

            // head[1] = location of the 2nd 'bytes' = heads size + tail[0].size = 64 + 64 = 128 = 0x80
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // 32 bytes

            // tail[0] = uint256(size) pad_right(data) = 0x01  0xaa... (size = 32 + 32 = 64)
            // size: uint256 = 0x01
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // 32 bytes
            // padded data: 0xaa...
            0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes

            // tail[1] = uint256(size) pad_right(data) = 0x01  0xbb... (size = 32 + 32 = 64)
            // size: uint256 = 0x01
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // 32 bytes
            // padded data: 0xbb ...
            0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes
        ])
        let data = value.encode()
        XCTAssertEqual(Array(data), Array(expected))
    }

    func testDecodeDynamicFixedArray() throws {
        let data = Data([
            // head[0] = location of the 1st 'bytes' = heads size = 64 = 0x40
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, // 32 bytes

            // head[1] = location of the 2nd 'bytes' = heads size + tail[0].size = 64 + 64 = 128 = 0x80
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // 32 bytes

            // tail[0] = uint256(size) pad_right(data) = 0x01  0xaa... (size = 32 + 32 = 64)
            // size: uint256 = 0x01
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // 32 bytes
            // padded data: 0xaa...
            0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes

            // tail[1] = uint256(size) pad_right(data) = 0x01  0xbb... (size = 32 + 32 = 64)
            // size: uint256 = 0x01
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // 32 bytes
            // padded data: 0xbb ...
            0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16 bytes
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32 bytes
        ])
        var value = Sol.FixedArray(size: 2, repeating: Sol.Bytes())
        var offset = 0
        try value.decode(from: data, offset: &offset)
        continueAfterFailure = false
        XCTAssertEqual(value.elements.count, 2)
        XCTAssertEqual(Array(value.elements[0].storage), [0xaa])
        XCTAssertEqual(Array(value.elements[1].storage), [0xbb])
        XCTAssertEqual(offset, 192)
    }
}
